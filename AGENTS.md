# LiDAR Standalone - Development Guide

## Project Structure

```text
lidar-standalone/
├── app/                    # Backend (Python FastAPI)
│   ├── api/v1/             # REST API endpoints (all under /api/v1 prefix)
│   │   ├── system.py       # System start/stop controls & status
│   │   └── websocket.py    # WebSocket streaming handling
│   ├── services/           # Lidar data parsing, Pipeline, and WebSocket handling
│   │   ├── lidar/
│   │   │   ├── protocol/   # LIDR binary format encoding/decoding
│   │   │   ├── workers/    # Multiprocessing workers (sick_scan.py, pcd.py)
│   │   │   └── sensor.py   # LidarSensor node class
│   │   ├── fusion/         # FusionService node for merging point clouds
│   │   ├── nodes/          # Directed Acyclic Graph (DAG) Execution Engine
│   │   │   ├── orchestrator.py   # NodeManager: DAG executor, edge routing, data flow
│   │   │   ├── node_registry.py  # Central registry for NodeDefinitions & Factory Builders
│   │   │   ├── node_factory.py   # Factory instantiator
│   │   │   ├── operation_node.py # Generic wrapper executing PipelineOperations
│   │   │   └── schema.py         # Type definitions for ports, properties, and nodes
│   │   ├── pipeline/       # Open3D Point Cloud Processing
│   │   │   ├── factory.py        # Central OperationFactory for instantiating logic
│   │   │   ├── base.py           # PipelineOperation abstract base class
│   │   │   └── operations/       # Individual processing algorithms (Crop, Filter, Outliers, etc.)
│   │   └── websocket/
│   │       └── manager.py  # WebSocket connection manager & connection multiplexer
│   ├── repositories/       # SQLite persistence layer mapping nodes and edges
│   └── static/             # Built Angular frontend (served at /)
├── web/                    # Modern Angular frontend
│   ├── src/
│   │   ├── app/
│   │   │   ├── core/       # API Services, Signal Store architectures, Models, WS Handlers
│   │   │   ├── features/   # Feature modules
│   │   │   │   ├── settings/
│   │   │   │   │   ├── components/flow-canvas/ # Node-RED style drag-and-drop workspace
│   │   │   │   │   └── components/dynamic-node-editor/ # Auto-generating config forms
│   │   │   │   └── workspaces/ # 3D Three.js visualizer for live point clouds
│   │   │   ├── layout/     # UI Shell routing
│   │   │   └── app.*       # Root component
│   ├── package.json
│   ├── angular.json
│   └── tailwind.config.js
├── config/
│   └── data.db             # SQLite database (gitignored, auto-created)
├── tests/                  # Unit tests (pytest)
├── scripts/                # Launch scripts (e.g. run_sim.sh)
└── AGENTS.md               # This architecture documentation
```

## Backend Stack & Architecture

- **FastAPI**: Core Python web framework for REST and WebSockets.
- **Open3D**: Point cloud manipulation, mathematics, clustering, and transformations.
- **AsyncIO & Multiprocessing**: High-performance isolated workers to process UDP LIDAR packets, streaming concurrently through an event loop.
- **NumPy**: Tensor matrix manipulations.

### The Node Orchestration Engine (DAG)

The backend has transitioned into a highly dynamic Directed Acyclic Graph (DAG) architecture. Instead of hardcoded pipelines, data flows from defined hardware sensors down through arbitrary operation trees.

1. **`NodeManager` (`orchestrator.py`)**:
   - Loads persisted `nodes` and `edges` from SQLite.
   - Maps physical target destinations (via IDs).
   - Serves as the high-level event router. Whenever a node completes its compute method, it calls `self.manager.forward_data(self.id, payload)`, and the Orchestrator distributes that array to all connected Edge targets.

2. **The Registry (`node_registry.py`)**:
   - Maintains a master `node_schema_registry` exposing node metadata (Inputs, Outputs, Properties, UI names, Icons) to the Angular front-end.
   - Bootstraps nodes utilizing builder functions (`@NodeFactory.register()`).
   - Dynamically resolves duplicate topics by appending a short-hash (e.g., `sensor_464724_raw_points`) to prevent WebSocket collisions. Debug output nodes actively intercept tracking and prevent WebSocket broadcasts entirely (`topic = None`).

3. **`OperationNode` (`operation_node.py`)**:
   - Universal async wrapper for processing nodes.
   - Holds an instance of a `PipelineOperation` generated by the `OperationFactory`.
   - Native threading optimization: runs Open3D routines off the main thread via `asyncio.to_thread` to prevent thread-locking the WebSockets API.

4. **Pipeline Operations Stack (`app/services/pipeline/operations`)**:
   - Discrete, atomic Open3D operations.
   - Includes: `Crop`, `Downsample`, `StatisticalOutlierRemoval`, `RadiusOutlierRemoval`, `PlaneSegmentation`, `Clustering`, `FilterByKey`, `BoundaryDetection`, and `DebugSave`.
   - Note: Visualization operations were entirely stripped from the backend to ensure host OS stability (X11/Wayland context issues); all 3D visualizations are rendered purely in the Angular frontend.

## Frontend Stack & Architecture

- **Angular 17+**: Utilizing Standalone components and modern control flows (`@if`, `@for`).
- **Angular Signals**: Extremely aggressive reactive state handling.
- **Three.js**: Custom WebGL rendering canvas specifically optimized for heavy Point Cloud arrays.
- **Synergy Design System** & **Tailwind CSS**.

### Flow Canvas (The Settings Editor)

Location: `web/src/app/features/settings/components/flow-canvas/`

The frontend application provides a stunning "Node-RED" style interactive canvas graph for routing LiDAR.

1. **State Independence**: The application employs strict separation of state variables. For example, loading flags are isolated (`isPaletteLoading` vs `isCanvasLoading`) so the Plugin Sidebar renders immediately, while the DOM engine explicitly waits for the Graph lines to finish calculating their SVG bezier offsets before lifting the overlay loader.
2. **Dynamic UI Form Generation**: The application parses the JSON properties dict defined by the backend `NodeDefinition` schemas to proactively yield typed, validated input fields (Number steppers, dropdowns, input strings) via the `DynamicNodeEditorComponent`. No hard-coded forms exist.
3. **Graph Algorithms**:
   - Auto-calculates bezier curve connections.
   - Port drag-and-drop targeting.
   - Employs live WebSockets tracking (rather than HTTP polling) to reflect immediate hardware telemetry bounds directly onto Node Cards (FPS stats, Error status, Last run ping).

### 3D Workspaces (Three.js Visualizer)

Location: `web/src/app/features/workspaces/`

The Workspace allows subscribing to any node that broadcasts data over WebSockets (e.g., `sensor_RAW`, `fused_xyz`, `cropped_813b1`).

1. **Multi-Topic Streaming**: Simultaneously decodes custom `LIDR` binary protocol via `MultiWebsocketService`.
2. **BufferGeometry Mastery**: Mutates WebGL arrays entirely in-place. If point count bounds fluctuate, ThreeJS geometries are resized; otherwise, positions execute direct array substitutions to achieve 60+ FPS playback on dense 100k+ point clouds.
3. **Persisted Viewports**: The active active topic list automatically synchronizes back to `localStorage` through reactive Angular effects, seamlessly resuming visualizer configurations upon refresh.

## Network Protocols

### WebSocket Binary Frame Format (LIDR)

Point cloud nodes do not send slow JSON arrays over network protocols. They pack memory blocks directly onto binary buffers decoded synchronously by standard DataViews on the client.

| Offset | Size  | Type    | Description               |
| ------ | ----- | ------- | ------------------------- |
| 0      | 4     | char[4] | Magic "LIDR"              |
| 4      | 4     | uint32  | Version                   |
| 8      | 8     | float64 | Timestamp                 |
| 16     | 4     | uint32  | Point count               |
| 20     | N\*12 | float32 | Points (x, y, z) \* count |

### Data Recording Subsystem

The backend explicitly integrates with `WebSocket` binary broadcasts to cleanly multiplex Point Cloud dumps.

1. **Frontend Initiation**: `flow-canvas-node.component.ts` strictly queries the realtime `s?.topic` or `s?.raw_topic` from the node status polling, not the raw input schema `config`. This is critical, as the graph builder generates secure short-hashes for overlapping nodes (e.g. `clustered_e13a49`) to prevent channel collisions.
2. **Backend API Fallbacks**: `POST /api/v1/recordings/start` receives the topic. If the UI falls back to an unhashed string, the backend actively crawls `node_manager.nodes.values()` to natively auto-resolve prefix mismatches before mounting the file writer handle.
3. **Lazy-Load Singleton Integration**: The `ConnectionManager` handling WebSocket payloads globally injects the `RecordingService` via a lazy-loaded method `_get_recorder()`. This averts circular startup dependencies while simultaneously ensuring `has_subscribers(topic)` detects active disk writes, stopping the backend hardware processes from blindly culling untethered network traffic dumps.
4. Multiple isolated disk files can concurrently record identical topics without crashing due to unique UUID generation per node request.

### REST System Flow

Most traditional API interaction follows this generic loop:

1. UI modifies DAG Node visually natively in RAM.
2. Angular sends simple JSON struct (`POST /api/v1/nodes` or `POST /api/v1/edges`).
3. SQLite repository mutates table row.
4. UI calls `POST /api/v1/nodes/reload`.
5. Orchestrator flushes event loops, terminates child UDP multiprocessing workers, and reads entirely fresh configuration blocks from disk, cleanly re-instantiating the new graph mapping.

## Standard Execution

**Start Simulator**:

```bash
sh scripts/run_sim.sh
```

_Triggers FastAPI uvicorn daemon. Falls over to recorded `.pcd` payload frames._

**Compile Frontend**:

```bash
cd web
npm run start
```

_Hosts angular framework proxy targeted to API endpoints at port `8004`._
